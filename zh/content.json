{"pages":[{"title":"概述","text":"@ver01/form 是一个无依赖的JsonSchema表单渲染引擎，支持当前主流的React主题，同时支持自定义表单主题适配，允许能力的无限扩展 在线示例 在线Schema表单演示 本地示例将项目Clone到本地编译本地示例 git clone git@github.com:ver01/form.git npm install npm run start 执行上述命令后，访问 http://localhost:8888 查看示例","link":"/zh/docs-form/index.html"},{"title":"初始化","text":"项目中引入NPM包 Form的核心NPM包为 @ver01/form. 通常情况下，你需要再引入一个主题包（例如Antd主题：@ver01/form-theme-antd）。或者你也可以使用你自己的前端框架栈，进行自定义主题。 初始化为：非受控模式 传入props：defaultValue 12345678&lt;Ver01Form schema={{ title: &quot;受控模式:&quot;, type: &quot;string&quot; }} defaultValue=&quot;hello World&quot; onChange={this.onChange.bind(this)}/&gt; 在线演示 初始化为：受控模式 传入props：value 12345678&lt;Ver01Form schema={{ title: &quot;Controlled Mode:&quot;, type: &quot;string&quot; }} value={this.state.value} onChange={this.onChange.bind(this)}/&gt; 在线演示","link":"/zh/docs-form/initialize.html"},{"title":"JsonSchema","text":"@ver01/form 通过 $vf_opt 字段，拓展了 Json Schema 的定义 $vf_opt.propsAny：字段值将会 mixin 到 value节点对应的所有widget上. widget的使用，会通过 组件 Schema 的 propsMixinList 字段，进行筛选 $vf_opt.widgetString：指定字段使用的widget. widget定义在 组件 Schema widgets 字段中 $vf_opt.option array 可用 orderable(default true) addable(default true) removeable(default true) string 可用 disabled readonly object 可用 order: [‘first-key’, ‘second-key’, ‘*’, ‘last-key’] $vf_opt.validate[ruleName]: ruleValue 参考 在线Schema表单演示 中的例子：sample-validation","link":"/zh/docs-form/jsonSchema.html"},{"title":"主题","text":"当前官方支持Antd主题，其他框架主题请按本文档方式自定义, 针对比较流行的框架，我们尽快推出官方方案，也欢迎大家提issue共建. 你可以通过 提交 Issue ~~ 反馈你希望支持的主题（预计生产周期在1周左右） 主题依赖@ver01/form 是一个独立NPM包，不需要其他依赖项 但是，非自定义情况下，我们推荐您引入我们提供的主题包，通常情况下主题包仅仅包含相关配置项，对于主题的依赖往往已经在你的项目中了，因此无需担心资源增长的问题。 官方主题 Antd 自定义主题组件 Schema我们提供了类似 Json 的 schema 语法，来定义你表单中用到的 ReactComponents. 表单的入口文件通常结构 如：https://github.com/ver01/form-theme-antd/blob/master/src/index.js. 入口文件对外export的结构如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Export 主题export default { validators: { // 内建的错误校验，只需要提供messagebuilder minLength: ({ value, ruleValue, schema }) =&gt; ({ errorType: &quot;feedbackStr&quot;, errorData: `should NOT be shorter than ${ruleValue} characters`, }), ... // 自定义校验，需要提供完整的校验逻辑 otherCustomValidLogic }, components: { // 5 个基础类型 string: { getWidget: [({ schema }) =&gt; ({ widgetName: &quot;readonly&quot;, widgetData: { text: &quot;True&quot;}, })], // 基础类型定制特殊情况使用的widget逻辑: 范围值格式 { widgetName, widgetData } widgets: { select: { formatter: val =&gt; (val ? &quot;true&quot; : &quot;false&quot;), // 生成组件使用的value normalizer: val =&gt; (val === &quot;true&quot; ? true : false), // 组件value输出时的normallizer component: FormItem, // 这里就是React Class/component propsMixinList: [&quot;style&quot;], // 表单的 JsonSchema 会通过 $vf 定义组件props，需要这里filter出要用的 props: formItemProps, // 这里是将定义拆分到其他文件中了 children: [ // 组件的children定义(递归定义) { component: Select, propsMixinList: [&quot;placeholder&quot;], props: { // 使用 $vf_ prefix 作为前缀的props，会动态生成的; 更多详情，参考下面的 [动态props生成规则] 章节 $vf_value: ({ value }) =&gt; value, $vf_onChange: ({ handle }) =&gt; handle.onChange } } ] }, radio: radioWidget // 这里是定义拆分到其他文件中了，定义方式同select }, // widget 的定义结构: { [widgetName]: WidgetComponentSchema } errorObjGenerator:({ errors }) =&gt; { const errorMessage = []; errors.map(error =&gt; { const { errorType, errorData } = error; switch (errorType) { default: errorMessage.push(errorData); break; } }); // 错误生成函数，返回将用作：errorObj return errorMessage.length ? { message: ( &lt;ul&gt; {errorMessage.map((it, ind) =&gt; ( &lt;li key={ind}&gt;{it}&lt;/li&gt; ))} &lt;/ul&gt; ), } : null; }, // 生成的 errorObj 将用于 WidgetComponentSchema 渲染组件 }, number, integer, boolean, null, // 1root only(for body holder) root, // 1control only(for control schema oneof anyof allof) control, // 2container array, object, },}; 动态props生成规则入参用于props123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 { isRoot: true, rootValue: {}, rootSchema: {}, parentSchema: {}, value: {}, schema: {}, objectKey: \"a\", arrayIndex: 3, handle: { onChange: () =&gt; {}, // for array canMoveUp: false, canMoveDown: false, canAppend: false, canRemove: false, moveUp: () =&gt; {}, moveDown: () =&gt; {}, append: () =&gt; {}, remove: () =&gt; {}, // for control hasSchemaControl: true, // child formnode has SchemaList schemaList: [{ schema: {}, valid: true, selected: true }], // no control is null schemaSelect: ind =&gt; { /* aform func */ }, }, schemaOption: { // read by schema.$vf_opt.option // for array: orderable: true, removable: true, appendable: true, // for string: disabled: false, readonly: false, fileHandle: () =&gt; {}, // ? // for object: order: [\"key_a\", \"key_b\"], }, formProps: { validators: {}, }, formOption: {}, errorObj: { // custom },}; 入参用于WidgetComponentSchema1234{ formatter: () =&gt; {}, normalizer: () =&gt; {},}","link":"/zh/docs-form/theme.html"},{"title":"错误校验","text":"表单错误校验的结果，会通过 onValidate 方法传出 （参数为 error）。 当表单校验发现错误项目，错误参数 error 定义如下: validateErrValuePath: 校验失败的字段路径 errorObj: 由 组件 Schema errorObjGenerator 函数输出. errors: 由 组件 Schema validators 函数输出 返回值是一个数组 元素定义为: [{ errorType: &quot;errorTypeString&quot;, errorData: AnyType }] 1234567891011121314151617181920212223242526render(){return &lt;div&gt; &lt;Ver01Form schema={{ &quot;type&quot;: &quot;object&quot;, &quot;required&quot;: [ &quot;firstName&quot;, ], &quot;properties&quot;: { &quot;firstName&quot;: { &quot;type&quot;: &quot;string&quot; } } }} value={{ firstName: &apos;&apos; }} // zero length string cause required check onValidate={error=&gt;this.setState({errors: error &amp;&amp; error.errors})} // error : { [validateErrValuePath]: {errorObj, errors} } /&gt; &lt;Button onClick={()=&gt;{ if (this.state.errors){ postServer(this.state.value); }else { console.info(this.state.errors); } }&gt;Submit&lt;/Button&gt;&lt;/div&gt;} 表单校验 Validate 同样可以通过 formProps(即引用@ver01/form传入的props) 传递给表单 也可以在 组件 Schema 中定义","link":"/zh/docs-form/validate.html"},{"title":"值的提交和回填","text":"表单初始值非受控模式 你需要通过 props: defaultValue 传入默认值 如果defaultValue和value两个props都未指定，则表单以非受控模式运行 为了支持部分表单初始值是异步获取的情况，允许defaultValue初始值是undefine，并且在首次变为非undefine时，将首次获取的值作为表单初始值。 123456// 非受控模式:&lt;Ver01Form schema={{ type: &apos;string&apos;}} defaultValue=&apos;helloWorld&apos; onChange={console.info}/&gt; 受控模式 你需要通过 props: value 传入表单值 表单会通过 props: onChange 返回新值，你需要完成你的逻辑后，将新值回写到 props: value 上，否者表单不会更新(因为是受控模式) 123456// 受控模式&lt;Ver01Form schema={{ type: &apos;string&apos;}} value={this.state.value} onChange={value=&gt;this.setValue({value})}/&gt; 获取表单的数据我们不支持任何get新式的表单数据导出，但是你可以通过onChange函数将表单变化后的新值存储起来，使用的时候，使用你存储的最新表单值即可。 任何表单值的变化，都会引发onChange函数，请放心。 12345678910render(){return &lt;div&gt; &lt;Ver01Form schema={{ type: &apos;string&apos;}} value={this.state.value} onChange={value=&gt;this.setValue({value})} /&gt; &lt;Button onClick={()=&gt;{postServer(this.state.value)}}&gt;Submit&lt;/Button&gt;&lt;/div&gt;}","link":"/zh/docs-form/value.html"}],"posts":[],"tags":[],"categories":[]}